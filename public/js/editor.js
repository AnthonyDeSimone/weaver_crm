var editor;

app.controller("VisualEditorController", function($scope, $timeout) {

    editor = this;
    $scope.editor = this;
    form.editor = this;

    /**
     * A reference to this object for nested functions.
     */
    var me = this;

    /**
     * The base 64 representation of the image generated by the editor.
     * @type {string}
     */
    this.base64 = '';

    /**
     * Whether or not the visual editor is in the process of closing (generating the image).
     * Will be true if currently closing, false if not.
     * @type {boolean}
     */
    this.is_closing = false;

    /**
     * Whether or not the editor is currently open.
     * @type {boolean}
     */
    this.is_open = false;

    /**
     *
     * @type {{horizontal_line: {draw: boolean, color: string, thickness: number}, grid: {draw: boolean, color: string, style: string}}}
     */
    this.options = {
        horizontal_line: {
            draw: false,
            color: "#000000",
            thickness: 2
        },
        grid: {
            draw: false,
            color: "#cccccc",
            style: "solid",
            size: 1,
            snap: false
        }
    };

    /**
     * This is which tab is selected on the right side.
     * @type {number}
     */
    this.selected_tab = 0;

    /**
     * The last tab selected.
     * @type {number}
     */
    this.last_tab = 0;

    /**
     * The visual components being used by the editor.
     * @type {Visuals}
     */
    
    this.visuals = new Visuals(this);

    /**
     * A reference to the barn object.
     * @type {Barn}
     */
    this.barn = this.visuals.barn;

    this.custom_visual = {
        resizing: false,
        width: 4,
        height: 2,
        stretch: true,
        size: "specify",
        text: "Sample Text",
        has_text: true,
        border: true,
        border_color: "#374b5f",
        filled: false,
        bg_color: "white"
    };

    this.selected_options = {
        x: 0,
        y: 0,
        w: 0,
        h: 0,
        rotation: 0,
        flipped: false,
        is_updating: false
    };

    this.getCustomVisualStyle = function() {
        if (!me.is_open) {
            return {};
        }
        var cus = me.custom_visual;

        // Custom block style
        var c_style = {
            "display": "block",
            "box-sizing": "border-box",
            "padding": "0",
            "margin": "auto",
            "cursor": "grab"
        };

        c_style["width"] = me.visuals.convertToPixels(cus.width) + "px";
        c_style["height"] = me.visuals.convertToPixels(cus.height) + "px";

        if (cus.border) {
            c_style["border"] = "2px solid " + cus.border_color;
        } else {
            c_style["border"] = "none";
        }

        if (cus.filled) {
            c_style["background-color"] = cus.bg_color;
        }

        return c_style;
    };

    this.getCustomSpanStyle = function() {
        if (!me.is_open) {
            return {};
        }
        var cus = me.custom_visual;

        // Inner span style
        var s_style = {
            "display": "block",
            "box-sizing": "border-box",
            "padding": "0",
            "margin": "0",
            "text-align": "center",
            "width": "100%",
            "position": "relative"
        };

        s_style["display"] = "table";
        s_style["vertical-align"] = "middle";
        s_style["padding"] = "0";
        s_style["width"] = "100%";
        s_style["position"] = "relative";

        s_style["font-size"] = "1.5em";

        s_style["position"] = "relative";
        s_style["top"] = "50%";
        s_style["transform"] = "translateY(-50%)";

        return s_style;
    };

    /******************************************************************************************************************
     ************************************************ Actions *********************************************************
     ******************************************************************************************************************/

    /**
     * Closes the visual editor and generates the base64 image string.
     */
    this.close = function() {
        // If already closing, do nothing.
        if (me.is_closing) {
            return;
        }
        // Show the user that something is being done (generating image) while the editor is closing.
        me.is_closing = true;
        // Asynchronously generate the image, then close the editor.
        me.generateImage(function() {
            $timeout(function() {
                me.is_open = false;
                me.is_closing = false;
            }, 0);
        });
    };

    this.draw = function() {
        if (!me.is_open) {
            return;
        }
        if (me.visuals.selected && me.visuals.selected.is_resizing) {
            return;
        }

        var canvas = $("#underlay");
        var w = canvas.width();
        var h = canvas.height();

        var barn = $("#barn-outline");
        var bo = {};
        bo.x = barn.offset().left - canvas.offset().left;
        bo.y = barn.offset().top - canvas.offset().top;
        bo.w = barn.width();
        bo.h = barn.height();

        canvas = canvas[0];
        var con = canvas.getContext("2d");
        canvas.width = w;
        canvas.height = h;

        var foot = me.visuals.convertToPixels(1);
        var size;

        var line = me.options.horizontal_line;
        var grid = me.options.grid;

        var drawLine = function(x1, y1, x2, y2) {
            con.beginPath();
            con.moveTo(x1, y1);
            con.lineTo(x2, y2);
            con.lineWidth = 1;
            con.strokeStyle = grid.color;
            con.stroke();
        };

        if (grid.draw) {
            size = grid.size;
            if (isNaN(size) || size < .1 || size > 20) {
                size = 1;
            }
            size = me.visuals.convertToPixels(size);
            // Grid x start
            var gxs = bo.x - Math.floor(bo.x / size) * size;
            // Grid y start
            var gys = bo.y - Math.floor(bo.y / size) * size;

            var pos = gxs;
            while (pos < w) {
                drawLine(pos, 0, pos, h);
                pos += size;
            }

            var pos = gys;
            while (pos < h) {
                drawLine(0, pos, w, pos);
                pos += size;
            }

        }

        if (line.draw) {
            size = line.thickness;
            con.fillStyle = line.color;
            var y = h / 2 - size / 2;
            var x = w / 2 + size / 2;

            if (form.options.style === 'Studio') {
                y -= foot;
            }
            
            // if (form.options.style === 'Rockport Garage') {
            //     con.fillRect(x, bo.y, size, bo.h)
            // }
            // else {
                con.fillRect(bo.x, y, bo.w, size);
            // }
        }

    };

    /**
     * Opens the visual editor and places all visual elements.
     */
    this.open = function() {
        // Before anything, make sure the editor is open.
        $timeout(function() {
            me.is_open = true;
        }, 0).then(me.update);
    };

    //noinspection JSUnusedLocalSymbols
    /**
     * Generates the image of the visual editor and stores its value in base64. Takes an optional width
     * and height parameter that will generate an image that exact size (centered with white background).
     *
     * Note: width/height not yet implemented.
     *
     * @param callback A function to call back on once generating image is complete.
     * @param [width] The desired width of the generated image.
     * @param [height] The desired height of the generated image.
     */
    this.generateImage = function(callback, width, height) {
        $timeout(function() {
            // Make sure no visual is selected (get rid of box and controls for image generation).
            me.selectVisual(null);
        }, 0).then(function() {
            //noinspection SpellCheckingInspection
            html2canvas($("#blueprint").get(0), {
                onrendered: function(canvas) {
                    var rect = me.visuals.getBoundingRectangle().toJson();
                    var blueprint = $("#blueprint");
                    var off = blueprint.offset();
                    // The bounding rectangle is calculated using offsets. This should get the
                    // bounding rectangle within the blueprint.
                    rect.x -= off.left;
                    rect.y -= off.top;
                    // Do some bounds checking to make sure the rectangle actually falls within
                    // the bounds of the blueprint. This will take into account the border of
                    // the blueprint so as not to get that in the generated image.
                    rect.x = Math.max(3, rect.x);
                    rect.y = Math.max(3, rect.y);
                    if (rect.x + rect.width > off.left + blueprint.width() - 6) {
                        rect.width = off.left + blueprint.width() - 6;
                    }
                    if (rect.y + rect.height > off.top + blueprint.height() - 6) {
                        rect.height = off.top + blueprint.height() - 6;
                    }
                    // Create a new canvas element and write the contents of the generated canvas
                    // within the bounds specified.
                    try {
                        var new_canvas = document.createElement("canvas");
                        new_canvas.width = rect.width;
                        new_canvas.height = rect.height;
                        var context = canvas.getContext("2d");
                        var image_data = context.getImageData(rect.x, rect.y, rect.width, rect.height);
                        new_canvas.getContext("2d").putImageData(image_data, 0, 0);
                        me.base64 = new_canvas.toDataURL();
                        // TODO implement generating an image within width and height parameters.
                        if (isFunction(callback)) {
                            callback();
                        }
                    } catch (ex) {
                        alert("Oh no! It looks like there was an error saving the image from the editor. " +
                        "Please try saving the form, reloading the page, then updating the visual editor again. " +
                        "If this error keeps happening, please contact the system administrator.");
                    }
                }
            });
        });
    };

    this.overlayClicked = function(event) {
        if ($(event.target).attr("id") == 'overlay') {
            me.selectVisual(null);
        }
    };

    this.selectTab = function(tab) {
        me.last_tab = tab;
        me.selected_tab = tab;
    };

    this.selectVisual = function(visual) {
        me.visuals.selectVisual(visual);
        me.updateVisualOption();
    };

    this.updateVisualOption = function() {
        if (me.selected_options.is_updating) {
            return;
        }
        /** @type {Visual} */
        var vis = me.visuals.selected;
        if (vis) {
            me.selected_tab = 5;
            var bounds = vis.getBounds();
            me.selected_options.x = bounds.x;
            me.selected_options.y = bounds.y;
            me.selected_options.w = bounds.width;
            me.selected_options.h = bounds.height;
            me.selected_options.rotation = vis.getRotation();
            me.selected_options.flipped = vis.flipped;
        } else {
            me.selected_tab = me.last_tab;
        }
        if (!$scope.$$phase) {
            $scope.$apply();
        }
    };

    this.visualOptionUpdated = function() {
        var op = me.selected_options;
        op.is_updating = true;
        /** @type {Visual} */
        var vis = me.visuals.selected;
        var bounds;
        if (vis != null) {
            bounds = vis.getBounds();
            if (isNaN(op.x)) {
                op.x = bounds.x;
            }
            if (isNaN(op.y)) {
                op.y = bounds.y;
            }
            if (isNaN(op.w)) {
                op.w = bounds.width;
            }
            if (isNaN(op.h)) {
                op.h = bounds.height;
            }
            if (isNaN(op.rotation)) {
                op.rotation = vis.getRotation();
            }
            // Force boolean value
            op.flipped = !!op.flipped;
            if (op.x != bounds.x || op.y != bounds.y) {
                vis.setFeetPosition(op.x, op.y);
            }
            if (op.w != bounds.width || op.h != bounds.height) {
                vis.setFeetSize(op.w, op.h);
            }
            if (op.rotation != vis.getRotation()) {
                vis.setRotation(op.rotation);
            }
            if (op.flipped != vis.flipped) {
                vis.flip();
            }
        }
        op.is_updating = false;
        me.updateVisualOption();
    };

    /******************************************************************************************************************
     ******************************************************************************************************************
     ******************************************************************************************************************/

    this.isVisualSection = function(sec) {
        for (var i = 0; i < sec.subsections.length; i++) {
            if (me.isVisualSubsection(sec.subsections[i]))
                return true;
            }
        };

    this.isVisualSubsection = function(sub) {
        for (var i = 0; i < sub.components.length; i++) {
            var comp = sub.components[i];
            if (!comp.show)
                continue;
            if (form.getDisplayImage(comp) != null || me.isRadioImage(comp))
                return true;
            }
        return false;
    };

    this.isRadioImage = function(comp) {
        //console.log(comp)
        if (comp.form_type != 'radio' || !comp.options)
            return false;
        for (var i = 0; i < comp.options.length; i++) {
            if (comp.options[i].image_url)
                return true;
            }
        return false;
    };

    /******************************************************************************************************************
     ************************************************* Startup ********************************************************
     ******************************************************************************************************************/

    this.update = function() {
        $timeout(function() {
            me.visuals.centerBarn();
            me.visuals.checkVisualOnOpens();
        }, 0).then(function() {
            $timeout(me.draw, 0);
        });
    };

    // Kind of a watch.
    this.visuals.barn.onChange(me.update);

    $scope.$watch(function() {
        var a,
            b;
        if (form.options.size == "Custom") {
            a = form.custom.size.len;
            b = form.custom.size.width;
        } else {
            a = form.options.size.len;
            b = form.options.size.width;
        }
        return {
            width: a,
            height: b
        };
    }, function(nv) {
        size_and_style = Object.assign({}, nv);
        size_and_style.style = form.options.style 

        me.visuals.barn.setDimensions(size_and_style);
        if(form.options.style == 'Studio'){
            form.editor.options.horizontal_line.draw = false;
        }
        else{
            form.editor.options.horizontal_line.draw = true;
        }

        if(form.options.style == 'Timber Ridge' || form.options.style == 'Bradford'){
            form.features = {
                'Solid Pine': 'Solid Pine',
                'Solid Cedar': 'Solid Cedar'
            };
        }
        else if(form.options.style == 'Dublin'){
            form.features = {
                'Pavillion Vinyl': 'Vinyl'
            }; 
        }
        else if(form.options.style == 'The Classic Garage' || form.options.style == 'Dutch Garage' || form.options.style == 'Rockport Garage' || form.options.style == 'Willow Creek Garage'){
            form.features = {
                'Deluxe': 'Duratemp',
                'Premier': 'Solid Pine',                
                'Vinyl': 'Vinyl'
            }; 
        }        
        else{
            form.features = {
                'Deluxe': 'Duratemp',
                'Premier': 'Solid Pine',
                'Vinyl': 'Vinyl',
                'Eco Pro': 'Eco Pro',
                'Custom': 'Custom'
            };
        }
    }, true);

    $scope.$watch(function() {
        return me.options;
    }, function() {
        me.draw();
    }, true);

    $scope.$watch(function() {
        return form.additions;
    }, function() {
        var comps = form.getAllComponents();
        for (var ci in comps) {
            if (comps.hasOwnProperty(ci)) {
                var comp = comps[ci];
                if (comp.id == 0)
                    continue;
                var quantity = form.getQuantity(comp);
                me.visuals.setMaxOf(comp, quantity);
            }
        }
    }, true);

    $scope.$watch(function() {
        return me.visuals.barn.dimensions.padding;
    }, me.update, true);

    $scope.$watch(function() {
        return me.selected_options;
    }, me.visualOptionUpdated, true);

    $(document).ready(function() {
        $(window).resize(me.update);
    });

    /******************************************************************************************************************
     ******************************************************************************************************************
     ******************************************************************************************************************/

    this.loadData = function(obj) {
        if (obj.hasOwnProperty("version") && obj.version == 2) {
            me.options = obj.options;
            me.selected_tab = obj.selected_tab;
            me.visuals = new Visuals(me, copyOf(obj.visuals));
        } else {

            // Old pixels per foot.
            var ppf = obj.pixels_per_foot;

            // If, for some reason, it wasn't defined, default to 52 (I need some value).
            if (!ppf || ppf <= 0) {
                ppf = 52;
            }

            // The padding x/y in feet of the old barn.
            var px = obj.barn.padding.x;
            var py = obj.barn.padding.y;

            // The new visuals object that will be used.
            var nv = {};

            // The default custom options for a visual.
            var cus = function() {
                return {is_custom: false, text: 'Sample Text', stretch: false, border: true, size: "specify"};
            };

            // Loop through and translate the old visual data into something compatible with the new
            // visuals, as well as translate their points so that they are based on top left of barn.
            for (var vi in obj.visuals) {
                //noinspection JSUnresolvedFunction
                if (obj.visuals.hasOwnProperty(vi)) {
                    var ov = obj.visuals[vi];

                    var id = "visual_" + (+ ov.tab_stop + 9000);

                    // Create the custom options for the new visual.
                    var custom = cus();

                    // If the old visual was a custom, copy over its stuff.
                    if (ov.custom) {
                        custom.is_custom = true;
                        custom.text = ov.custom.text;
                        custom.stretch = ov.custom.stretch;
                        custom.border = ov.custom.border;
                        custom.size = ov.custom.size;

                        if (ov.custom.hasOwnProperty("has_text")) {
                            custom.has_text = ov.custom.has_text;
                        } else {
                            custom.has_text = true;
                        }

                        // For some reason, I stored width and height in the custom object if it was a custom.
                        if ((!isDefined(ov.width) || !isDefined(ov.height)) && (isDefined(ov.custom.width) && isDefined(ov.custom.height))) {
                            // TODO auto size fix.
                            if (custom.size == "auto") {
                                ov.width = 4 * ppf;
                                ov.height = 2 * ppf;
                            } else {
                                ov.width = ov.custom.width;
                                ov.height = ov.custom.height;
                            }
                        }

                    }

                    // Add the new visual to the new visuals object.
                    nv[id] = {
                        bounds: {
                            position: {
                                x: ov.x - px,
                                y: ov.y - py
                            },
                            dimensions: {
                                width: isDefined(ov.width)
                                    ? ov.width / ppf
                                    : 0,
                                height: isDefined(ov.height)
                                    ? ov.height / ppf
                                    : 0
                            }
                        },
                        component_id: ov.component_id,
                        custom: custom,
                        flipped: ov.flipped,
                        id: id,
                        // Why didn't I save the image url?
                        image_url: form.getDisplayImage(form.getComponentById(ov.component_id)),
                        rotation: ov.rotation,
                        z_order: ov.z_order
                    };
                }
            } 

            // Create the new visuals object given the data.
            me.visuals = new Visuals(me, {
                visuals: nv,
                id_count: (+ obj.id_count + 9000),
                z_top: (+ obj.id_count + 1),
                barn: {
                    image_url: obj.barn.image_url,
                    dimensions: {
                        height: obj.barn.height,
                        width: obj.barn.width,
                        // The way padding works is completely different. Set to 3x3.
                        padding: {
                            x: 3,
                            y: 3
                        }
                    }
                }
            });
        }

        // The same regardless of version differences.
        me.barn = me.visuals.barn;
        me.barn.onChange(me.update);
        me.base64 = obj.base64;

        $timeout(function() {
            me.update();
        }, 0);
    };

    this.toJSON = function() {
        return {
            /*base64: me.base64, // This is added to the base save object later. */
            options: copyOf(me.options),
            selected_tab: me.selected_tab,
            version: VERSION_NUMBER,
            visuals: copyOf(me.visuals.toJSON())
        };
    };

    /**
     * Generates a range for visual section stuff.
     * @param {number} num Length of array to return.
     * @returns {Array} Array filled with indices.
     */
    this.range = function(num) {
        var arr = [];
        for (var i = 0; i < num; i++)
            arr[i] = i;
        return arr;
    };

});

app.directive("blueprint", function($timeout) {
    //noinspection JSUnusedLocalSymbols
    return {
        link: function(scope, elem, attrs) {
            var overlay = $("#overlay");
            overlay.droppable({
                accept: function(blah) {
                    return blah.hasClass("new-draggable") || blah.hasClass("waiting") || blah.hasClass("custom_visual");
                },
                drop: function(event, ui) {
                    var drop = ui.helper;
                    var left = drop.offset().left;
                    var top = drop.offset().top;

                    $timeout(function() {
                        if (ui.helper.hasClass("custom_visual")) {
                            var cus = copyOf(editor.custom_visual);
                            cus.is_custom = true;
                            var cv = $("#custom_visual");
                            editor.visuals.addVisual(0, left, top, false, cus, cv.outerWidth(), cv.outerHeight());
                        } else {
                            var comp = form.getComponentById(ui.helper.attr("data-id"));
                            if (comp && isDefined(comp['i_width']) && isDefined(comp['i_height']) && comp.i_width && comp.i_height) {
                                editor.visuals.addVisual(ui.helper.attr("data-id"), left, top, ui.helper.hasClass("waiting")
                                    ? false
                                    : true, null, 'f' + comp.i_width, 'f' + comp.i_height);
                            } else {
                                editor.visuals.addVisual(ui.helper.attr("data-id"), left, top, ui.helper.hasClass("waiting")
                                    ? false
                                    : true);
                            }
                        }
                    }, 0);
                }
            });
            overlay.mousedown(function(e) {
                if ($(e.target).attr("id") != "overlay")
                    return;
                editor.overlayClicked(e);
            });
        }
    }
});

app.directive("accordionComponent", [
    "$timeout",
    function($timeout) {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                $timeout(function() {
                    var $ = jQuery;
                    var target = $(element);
                    var elem = $(attr.accordionComponent);
                    elem.css('cursor', 'pointer');
                    var parent = $(target.data('parent'));
                    if (!parent.data('weaver-id')) {
                        $.id_count = $.id_count || 0;
                        $.id_count++;
                        parent.data('weaver-id', $.id_count);
                    }
                    var id = parent.data('weaver-id');
                    var aclass = 'weaver-accordion-' + id;

                    target.addClass(aclass).addClass('weaver-accordion-target').hide(500).data('hidden', true);
                    elem.addClass(aclass).addClass('weaver-accordion-handle');

                    elem.click(function() {
                        var hidden = target.data('hidden');
                        $('.weaver-selected.' + aclass).removeClass('weaver-selected');
                        if (hidden) {
                            $('.' + aclass + '.weaver-accordion-target').each(function() {
                                var item = $(this);
                                if (item !== target) {
                                    item.hide(500);
                                    item.data('hidden', true);
                                }
                            });
                            target.show(500).addClass('weaver-selected');
                            elem.addClass('weaver-selected');
                        } else {
                            target.hide(500);
                        }
                        target.data('hidden', !hidden);
                    })
                }, 0);
            }
        }
    }
]);

app.directive("blueprintDraggable", function($timeout) {
    //noinspection JSUnusedLocalSymbols
    return {
        scope: {
            visual: "=vis"
        },
        link: function(scope, elem, attrs) {

            let check = function() {
                visual.check_overlapping();
                scope.$apply();
            }

            //noinspection JSValidateTypes
            /** @type {Visual} */
            var visual = scope.visual;
            $timeout(function() {
                var span = $("#" + visual.id);
                var bounds = visual.getBounds();
                // If the bounds of the visual have not yet been set, then check to see if
                // the size can be set by its image. If the editor has not been opened yet,
                // then wait until the editor is opened before attempting sizing (since the
                // pixels per foot needs to be known to set a pixel size).
                if ((bounds.height <= 0 || bounds.width <= 0) && !visual.custom.is_custom) {
                    var img = new Image();
                    img.onload = function() {
                        var height = img.height;
                        var width = img.width;
                        if (editor && editor.is_open) {
                            $timeout(function() {
                                visual.setPixelSize(width, height);
                            }, 0);
                        } else {
                            visual.set_on_open = {
                                width: width,
                                height: height
                            };
                        }
                    };
                    img.src = visual.image_url;
                }

                span.draggable({
                    containment: "#overlay",
                    stop: function() {
                        visual.setOffset(span.offset());
                        // $("#xpos").val(visual.getBounds().x);
                        check();
                    }
                });

                if (!visual.custom.is_custom || (visual.custom.is_custom && visual.custom.size == "specify")) {
                    span.resizable({
                        start: function() {
                            visual.is_resizing = true;
                            span.find(".on-blueprint").first().hide();
                        },
                        stop: function() {
                            $timeout(function() {
                                visual.is_resizing = false;
                                if (visual.getRotation() % 2 == 0) {
                                    visual.setPixelSize(span.outerWidth(), span.outerHeight());
                                } else {
                                    visual.setPixelSize(span.outerHeight(), span.outerWidth());
                                }
                                span.find(".on-blueprint").first().show();
                                visual.setOffset(span.offset());
                                if (visual.getRotation() % 2 == 0) {
                                    visual.setPixelSize(span.outerWidth(), span.outerHeight());
                                } else {
                                    visual.setPixelSize(span.outerHeight(), span.outerWidth());
                                }
                                check();
                            }, 0);
                        },
                        resize: function(e, ui) {
                            span.width(ui.size.width);
                            span.height(ui.size.height);
                            span.height(ui.size.height);
                            check();
                        }
                    });
                }

                check();

            }, 0);
        }
    };
});

app.directive("newDraggable", function() {
    //noinspection JSUnusedLocalSymbols
    return {
        link: function(scope, elem, attrs) {
            $(elem).draggable({
                revert: "invalid",
                cursor: "grab",
                containment: "#visual-editor",
                helper: function() {
                    var copy = $(this).clone();
                    copy.detach().appendTo("#visual-editor").css("z-index", 9999);
                    return copy;
                }
            }).addClass("new-draggable");
        }
    }
});

app.directive("waiting", function() {
    //noinspection JSUnusedLocalSymbols
    return {
        link: function(scope, elem, attrs) {
            $(elem).draggable({
                revert: "invalid",
                cursor: "grab",
                containment: "#visual-editor",
                helper: function() {
                    var copy = $(this).clone();
                    copy.detach().appendTo("#visual-editor").css("z-index", 9999);
                    return copy;
                }
            }).addClass("waiting");
        }
    }
});

app.directive("custom", function() {
    //noinspection JSUnusedLocalSymbols
    return {
        link: function(scope, elem, attrs) {
            $(elem).draggable({
                revert: "invalid",
                cursor: "grab",
                containment: "#visual-editor",
                helper: function() {
                    var copy = $(this).clone();
                    copy.detach().appendTo("#visual-editor").css("z-index", 9999);
                    return copy;
                }
            }).addClass("custom_visual");
        }
    }
});
